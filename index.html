<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>142857 Cyclic Permutations</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    background: #000;
    height: 100%;
    font-family: monospace;
    overflow: hidden;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  #container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    width: 100%;
    height: 100%;
    padding: 8px;
  }
  #spacer-top {
    flex: 2;
  }
  canvas {
    display: block;
    flex-shrink: 1;
  }
  #spacer-mid {
    flex: 1;
  }
  #spacer-bottom {
    flex: 5;
  }
  .btn-row {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    flex-shrink: 0;
    padding: 6px 0;
  }
  .btn-row button {
    background: #222;
    color: #fff;
    border: 1px solid #555;
    font-family: monospace;
    cursor: pointer;
    border-radius: 4px;
    -webkit-tap-highlight-color: transparent;
  }
  .btn-row button:hover {
    background: #444;
  }
  #controls button {
    padding: 10px 20px;
    font-size: 15px;
    min-height: 44px;
  }
  #highlight-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    flex-shrink: 0;
    padding: 4px 0 0 0;
  }
  #highlight-section .hl-label {
    color: #787878;
    font-size: 13px;
    margin-bottom: 4px;
  }
  #highlight-controls {
    gap: 8px;
  }
  #highlight-controls button {
    width: 44px;
    height: 44px;
    font-size: 18px;
    font-weight: bold;
    border-radius: 50%;
    padding: 0;
    line-height: 44px;
    text-align: center;
  }
  #highlight-controls button.hl-active {
    background: #c8b200;
    color: #000;
    border-color: #ffdd00;
  }
</style>
</head>
<body>
<div id="container">
  <div id="spacer-top"></div>
  <canvas id="canvas"></canvas>
  <div id="spacer-mid"></div>
  <div id="highlight-section">
    <span class="hl-label">Highlight:</span>
    <div id="highlight-controls" class="btn-row">
    <button data-digit="1">1</button>
    <button data-digit="4">4</button>
    <button data-digit="2">2</button>
    <button data-digit="8">8</button>
    <button data-digit="5">5</button>
    <button data-digit="7">7</button>
    </div>
  </div>
  <div id="controls" class="btn-row">
    <button id="btnMode">Multiply and Return</button>
    <button id="btnPause">Pause</button>
  </div>
  <div id="spacer-bottom"></div>
</div>
<script>
(() => {
  // ── Canvas & responsive layout ────────────────────────────────────────
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const container = document.getElementById("container");

  // Layout values derived from canvas size (recalculated on resize)
  let W, H, dpr;
  let topY, bottomY, radius, xPositions;
  let labelFont, modeFont, digitFont;
  let guideMargin;

  function recalcLayout() {
    dpr = window.devicePixelRatio || 1;

    // Measure available space (container minus button rows)
    const btns = container.querySelectorAll(".btn-row");
    let btnHeight = 0;
    btns.forEach(el => { btnHeight += el.offsetHeight; });

    const pad = 16;
    const availW = container.clientWidth - pad;
    const availH = container.clientHeight - btnHeight - pad;

    // Canvas logical size: fit within available area, maintain 3:4 aspect
    const aspect = 3 / 4;
    if (availW / availH < aspect) {
      W = Math.floor(availW);
      H = Math.floor(W / aspect);
    } else {
      H = Math.floor(availH);
      W = Math.floor(H * aspect);
    }
    // Ensure minimum usable size
    W = Math.max(W, 210);
    H = Math.max(H, 280);

    // Set canvas CSS size and backing buffer for sharp rendering
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    canvas.width = Math.floor(W * dpr);
    canvas.height = Math.floor(H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Derive layout from logical canvas size
    topY = H * 0.23;
    bottomY = H * 0.77;
    radius = Math.max(W * 0.038, 16);
    guideMargin = W * 0.06;

    xPositions = [];
    for (let i = 0; i < 6; i++) {
      xPositions.push(Math.floor(W / 7 * (i + 1)));
    }

    // Font sizes proportional to width (keeps text consistent with circle size)
    labelFont = Math.max(Math.floor(W * 0.038), 12) + "px monospace";
    modeFont = Math.max(Math.floor(W * 0.038), 12) + "px monospace";
    digitFont = "bold " + Math.max(Math.floor(radius * 1.1), 12) + "px monospace";
  }

  // ── Timing (ms) ───────────────────────────────────────────────────────
  const HOLD_MS = 3000;
  const MOVE_MS = 3000;

  // ── Sequence data ─────────────────────────────────────────────────────
  const START = [1, 4, 2, 8, 5, 7];
  const ALL_ORDERS = [
    [1, 4, 2, 8, 5, 7],
    [2, 8, 5, 7, 1, 4],
    [4, 2, 8, 5, 7, 1],
    [5, 7, 1, 4, 2, 8],
    [7, 1, 4, 2, 8, 5],
    [8, 5, 7, 1, 4, 2],
  ];
  const LABELS = [
    "Initial Order: 142857",
    "Multiplication 1: 285714",
    "Multiplication 2: 428571",
    "Multiplication 3: 571428",
    "Multiplication 4: 714285",
    "Multiplication 5: 857142",
  ];
  const MODE_NAMES = ["Multiply and Return", "Continuous Multiplication"];

  // ── Helpers ───────────────────────────────────────────────────────────
  function easeInOut(t) { return 0.5 - 0.5 * Math.cos(Math.PI * t); }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function digitCol(digit, order) { return order.indexOf(digit); }
  function yFor(pos) { return pos === "top" ? topY : bottomY; }

  // ── Phase builders ────────────────────────────────────────────────────
  function buildMultiplyAndReturn() {
    const phases = [];
    for (let m = 0; m < 5; m++) {
      phases.push({ type: "hold", order: 0, at: "top" });
      phases.push({ type: "move", fromOrder: 0, toOrder: m + 1, fromY: "top", toY: "bottom" });
      phases.push({ type: "hold", order: m + 1, at: "bottom" });
      phases.push({ type: "move", fromOrder: m + 1, toOrder: 0, fromY: "bottom", toY: "top" });
    }
    return phases;
  }

  function buildContinuous() {
    const stops = [
      [0, "top"], [1, "bottom"], [2, "top"],
      [3, "bottom"], [4, "top"], [5, "bottom"],
    ];
    const phases = [];
    for (let i = 0; i < stops.length; i++) {
      const [orderIdx, pos] = stops[i];
      const [nextOrderIdx, nextPos] = stops[(i + 1) % stops.length];
      phases.push({ type: "hold", order: orderIdx, at: pos });
      phases.push({ type: "move", fromOrder: orderIdx, toOrder: nextOrderIdx, fromY: pos, toY: nextPos });
    }
    return phases;
  }

  function labelForPhase(p) {
    return p.type === "hold" ? LABELS[p.order] : LABELS[p.toOrder];
  }

  // ── State ─────────────────────────────────────────────────────────────
  const phaseTables = [buildMultiplyAndReturn(), buildContinuous()];
  let mode = 0;
  let phase = 0;
  let phaseStart = performance.now();
  let paused = false;
  let pauseElapsed = 0;
  let highlightDigit = null;

  // ── Controls ──────────────────────────────────────────────────────────
  const btnMode = document.getElementById("btnMode");
  const btnPause = document.getElementById("btnPause");
  const hlButtons = document.querySelectorAll("#highlight-controls button[data-digit]");

  btnMode.addEventListener("click", () => {
    mode = 1 - mode;
    phase = 0;
    phaseStart = performance.now();
    pauseElapsed = 0;
    btnMode.textContent = MODE_NAMES[mode];
  });

  btnPause.addEventListener("click", () => {
    if (paused) {
      phaseStart = performance.now() - pauseElapsed;
      paused = false;
      btnPause.textContent = "Pause";
    } else {
      pauseElapsed = performance.now() - phaseStart;
      paused = true;
      btnPause.textContent = "Resume";
    }
  });

  function updateHlButtons() {
    hlButtons.forEach(btn => {
      const d = parseInt(btn.dataset.digit);
      btn.classList.toggle("hl-active", d === highlightDigit);
    });
  }

  hlButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const d = parseInt(btn.dataset.digit);
      highlightDigit = (highlightDigit === d) ? null : d;
      updateHlButtons();
    });
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "m" || e.key === "M") btnMode.click();
    else if (e.key === " ") { e.preventDefault(); btnPause.click(); }
    else if (e.key === "h" || e.key === "H") { highlightDigit = null; updateHlButtons(); }
    else {
      const num = parseInt(e.key);
      if ([1,4,2,8,5,7].includes(num)) {
        highlightDigit = (highlightDigit === num) ? null : num;
        updateHlButtons();
      }
    }
  });

  // ── Drawing ───────────────────────────────────────────────────────────
  function drawCircle(digit, cx, cy, highlighted) {
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = highlighted ? "#ffdd00" : "#fff";
    ctx.fill();

    ctx.fillStyle = "#000";
    ctx.font = digitFont;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(String(digit), cx, cy);
  }

  // ── Resize handling ───────────────────────────────────────────────────
  let resizeTimer;
  function onResize() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(recalcLayout, 50);
  }
  window.addEventListener("resize", onResize);
  recalcLayout();

  // ── Main loop ─────────────────────────────────────────────────────────
  function frame(now) {
    const phases = phaseTables[mode];

    // Timing
    let elapsed = paused ? pauseElapsed : now - phaseStart;
    let phaseInfo = phases[phase];
    let dur = phaseInfo.type === "hold" ? HOLD_MS : MOVE_MS;

    if (!paused && elapsed >= dur) {
      phase = (phase + 1) % phases.length;
      phaseStart = now;
      elapsed = 0;
      phaseInfo = phases[phase];
      dur = phaseInfo.type === "hold" ? HOLD_MS : MOVE_MS;
    }

    const t = Math.min(elapsed / dur, 1.0);

    // Compute positions
    const positions = [];
    if (phaseInfo.type === "hold") {
      const order = ALL_ORDERS[phaseInfo.order];
      const cy = yFor(phaseInfo.at);
      for (const digit of START) {
        positions.push([xPositions[digitCol(digit, order)], cy]);
      }
    } else {
      const fromOrder = ALL_ORDERS[phaseInfo.fromOrder];
      const toOrder = ALL_ORDERS[phaseInfo.toOrder];
      const fromCy = yFor(phaseInfo.fromY);
      const toCy = yFor(phaseInfo.toY);
      const e = easeInOut(t);
      for (const digit of START) {
        const fc = digitCol(digit, fromOrder);
        const tc = digitCol(digit, toOrder);
        positions.push([
          lerp(xPositions[fc], xPositions[tc], e),
          lerp(fromCy, toCy, e),
        ]);
      }
    }

    // ── Draw ──────────────────────────────────────────────────────────
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // Guide lines
    ctx.strokeStyle = "#1e1e1e";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(xPositions[0] - guideMargin, topY);
    ctx.lineTo(xPositions[5] + guideMargin, topY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(xPositions[0] - guideMargin, bottomY);
    ctx.lineTo(xPositions[5] + guideMargin, bottomY);
    ctx.stroke();

    // Circles
    for (let i = 0; i < START.length; i++) {
      drawCircle(START[i], positions[i][0], positions[i][1], START[i] === highlightDigit);
    }

    // Sequence label
    const label = labelForPhase(phaseInfo);
    ctx.fillStyle = "#fff";
    ctx.font = labelFont;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, W / 2, H * 0.07);

    // Mode label
    ctx.font = modeFont;
    ctx.fillText(MODE_NAMES[mode], W / 2, H * 0.13);

    // Paused indicator
    if (paused) {
      ctx.font = labelFont;
      ctx.fillText("PAUSED", W / 2, H / 2);
    }


    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
